{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> OpenDSM: An open-source python package to develop and implement standard methods for predicting metered energy usage. </p> <p></p> <p> </p> <p>OpenDSM (formerly OpenEEmeter) is an open source library used to measure the impacts of demand-side programs by using historical data to fit models and then create predictions (counterfactuals) to compare to post-intervention, observed energy usage.</p>"},{"location":"#key-features-include","title":"Key Features include:","text":"<ul> <li>Open Source: All code is open source, making OpenDSM an excellent choice for measuring energy savings when results must be transparent and reproducible.</li> <li>Fast: A key tenet of OpenDSM modules are to be highly efficient, critical when there are millions of meters to be modeled. </li> <li>Easy and Intuitive: The API interface is inspired by scikit-learn, a well-known data science package for building models. Just fit and predict.</li> <li>Pandas DataFrame Support: Input data and predictions use pandas DataFrames, a well-known format for data scientists and engineers.</li> <li>Model Serialization and Deserialization: Models can be serialized into dictionaries or json objects, saved, and deserialized later.</li> </ul>"},{"location":"#core-modules","title":"Core Modules","text":""},{"location":"#openeemeter","title":"OpenEEmeter","text":"<p>Create long-term models fit on historical data to generate predictions of energy consumption</p> <ul> <li>Models to Fit Your Data: Billing, daily, and hourly models, depending on the time-series resolution</li> <li>Input Data Formatting: Meter usage and temperature time series are input to models through data classes to ensure standardization and avoid common pitfalls</li> <li>Data and Model Sufficiency: Native sufficiency checking to verify measurement compliance with the approved methodology</li> </ul>"},{"location":"#drmeter","title":"DRmeter","text":"<p>Create short-term models fit on historical data to generate predictions of energy consumption </p> <ul> <li>Hourly Model: All demand response models use hourly resolution data</li> </ul>"},{"location":"#comparison-groups","title":"Comparison Groups","text":"<p>Assign comparison groups (CGs) to correct OpenEEmeter models using non-participant population through one of the following methods</p> <ul> <li>Comparison Group Clustering: Cluster on model error profiles to select unique CG for each treatment meter</li> <li>Individual Meter Matching: Create population-level corrections by choosing the nearest n meters using Euclidean distance</li> <li>Stratified Sampling: Select meters for CG based upon shared characteristics (outdated methdology)</li> </ul> <p> * Comparison groups are currently being added to OpenDSM but are a planned feature for future versions. </p>"},{"location":"#eeweather","title":"EEweather","text":"<p>Get the most appropriate weather data for a location</p> <ul> <li>Match Location: Select a weather station using latitude/longitude or ZIP code (ZCTA)</li> <li>Climate Zone Sensitive: Ensures that the selected weather station is within the same climate zone</li> <li>Reliable Data Sources: Utilizes US Census Bureau, NOAA NCDC, and NREL as primary data sources</li> </ul> <p> * Available in the OpenDSM GitHub organization (link).  * In the future EEweather will be available as a module with the OpenDSM library. </p>"},{"location":"community/","title":"Community","text":"<p> OpenDSM: An open-source python package to develop and implement standard methods for predicting metered energy usage. </p> <p></p> <p> </p> <ul> <li> <p>Join the LF Energy discussion group here.</p> <ul> <li>There are no active working groups at present.</li> <li>If you were part of a prior working group or in the LFE discussion group, you will be alerted the next time one begins.</li> </ul> </li> <li> <p>If you have any issues or contributions that you would like to discuss, please use either the discussion group or github under issues, pull requests or discussions.</p> </li> </ul> <p>We strictly adhere to our code of conduct and contribution guidelines.</p>"},{"location":"install/","title":"Install","text":"<p> OpenDSM: An open-source python package to develop and implement standard methods for predicting metered energy usage. </p> <p></p> <p> </p>"},{"location":"install/#installing-opendsm","title":"Installing OpenDSM","text":"<p>There are two supported ways to install OpenDSM:</p> <p>-- Install the latest stable release from PyPI. This is best for most users.</p> <p>-- Build the package from source at https://github.com/opendsm/opendsm. This is best for advanced users and developers.</p>"},{"location":"documentation/","title":"Documentation","text":""},{"location":"documentation/#modules","title":"Modules","text":""},{"location":"documentation/#openeemeter","title":"OpenEEmeter","text":"<p>Create long-term models fit on historical data to generate predictions of energy consumption</p>"},{"location":"documentation/#drmeter","title":"DRmeter","text":"<p>Create short-term models fit on historical data to generate predictions of energy consumption </p>"},{"location":"documentation/#comparison-groups","title":"Comparison Groups","text":"<p>Assign comparison groups (CGs) to correct OpenEEmeter models using non-participant population through one of the following methods</p> <p> * Comparison groups are currently being added to OpenDSM but are a planned feature for future versions. </p>"},{"location":"documentation/#eeweather","title":"EEweather","text":"<p>Get the most appropriate weather data for a location</p> <p> * Available in the OpenDSM GitHub organization (link).  * In the future EEweather will be available as a module with the OpenDSM library. </p>"},{"location":"documentation/general_concepts/","title":"General Concepts","text":""},{"location":"documentation/general_concepts/#why-predict-energy-usage","title":"Why Predict Energy Usage?","text":"<p>If you are new to the energy industry, you may be asking yourself what the use cases for predicting energy usage are. In truth, there are many use cases for predicting energy usage, and the ability to do so accurately has far-reaching consequences from the economics of a single household to the stability of the entire grid.</p> <p>Common Use Cases Include:</p> <ul> <li>Forecasting load using weather forecasts to ensure adequate energy supply for the days, weeks, months, and years ahead.</li> <li>Determining the impact of interventions such as energy efficiency and demand response. This includes:<ul> <li>Understanding the financial impact of installed interventions to accurately track ROI.</li> <li>Utilities measuring the impact of these interventions on the utility grid and effectively utilizing them as grid resources.</li> </ul> </li> <li>Implementing \"continuous commissioning\" at buildings to track changes in energy usage and diagnose equipment issues.</li> <li>And many more...</li> </ul> <p>In this documentation we'll be focused on determining energy savings. After exploring this use case, you will have all the tools needed to apply OpenDSM for any use case desired.</p>"},{"location":"documentation/general_concepts/#quantifying-energy-savings","title":"Quantifying Energy Savings","text":"<p>Within the realm of energy efficiency, there are many different ways to calculate energy savings. The fundamental problem in calculating energy savings is the production of a \"counterfactual\". What would the energy usage have been in the absence of a specific intervention such as a new HVAC system? This is impossible to truly know, but several techniques are commonly used to accomplish this.</p>"},{"location":"documentation/general_concepts/#deemed-savings-engineering-estimates","title":"Deemed Savings / Engineering Estimates","text":"<p>This method involves contrasting the current condition of the building with the future condition of the building. This may mean comparing an existing refrigeration system with a newly installed one that is twice as efficient, or perhaps estimating the impact of behavioral changes at a site that is adapting new working procedures.</p> <p>The fundamental problem with this method is that it involves many assumptions. For example, what if the house that just installed the ultra-efficient refrigerator moves their old one into the garage? What if workers do not adapt the new working procedures as expected? Engineers and analysts can attempt to increase the accuracy of their calculations by spending more time tuning calculations to a specific site, but this increases overhead and takes time without any guarantee of increasing accuracy.</p>"},{"location":"documentation/general_concepts/#contrasting-current-usage-with-prior-usage","title":"Contrasting Current Usage with Prior Usage","text":"<p>This method involves simply comparing the current year's usage vs. the previous year. Although this is quickly done and leverages real meter data, it disregards the difference in conditions between the two years - in particular, temperature - which can have a huge impact on the energy usage at a site.</p>"},{"location":"documentation/general_concepts/#randomized-control-trial","title":"Randomized Control Trial","text":"<p>This method involves finding \"nearly identical\" sites that are not receiving interventions and comparing the energy usage to those receiving interventions. This side steps the temporal issue of different conditions in each year, but also introduces new challenges with finding \"nearly identical\" building to match with those receiving interventions. This can be difficult since no building is truly identical with its energy usage, but this can be compensated for with higher sample sizes and is best for residential programs.</p>"},{"location":"documentation/general_concepts/#estimate-usage-with-a-model","title":"Estimate Usage with a Model","text":"<p>This method involves using a model to predict energy usage and then comparing it to the actual usage to determine savings. With EEmeter, this approach relies entirely on temperature and meter data to create a model that can be used to predict energy usage. </p> <p>The pros of this method include:</p> <ul> <li>No need for ad-hoc assumptions - only actual meter data and temperature impact the model.</li> <li>Temperature data is used to accurately predict energy usage and contrast energy usage between different time periods.</li> <li>No need for finding \"nearly identical\" buildings.</li> <li>Method is suitable for most buildings.</li> </ul> <p>In addition, when using EEmeter with default configuration, users can be assured of consistent methods to determine energy savings. This is a fundamentally important point when calculating energy savings - consistency. If five different people come up with five different answers, which one do you trust? If estimates are coming from parties that stand to benefit from higher savings estimates (such as energy service companies, engineers, contractors, etc), these numbers are even harder to trust. By using standardized methods, the savings calculations are deterministic and avoid dangerous assumptions.</p>"},{"location":"documentation/general_concepts/#intervention-lifecycle","title":"Intervention Lifecycle","text":"<p>When calculating savings from an intervention, it is important to define temporal periods as these impact how we train and use our model. For a typical efficiency intervention, we will define three periods:</p> <ul> <li>Baseline Period: The period leading up to the intervention period that the model is trained on. For efficiency projects, this is 365 days. For demand response, the period may be shorter.</li> <li>Blackout Period: The period in which the intervention is being installed that should not be included in either baseline or reporting periods. During this period, energy usage is often erratic due to the installation process. For some interventions, the blackout period may be months, and for others there may be no blackout period (i.e. demand response).</li> <li>Reporting Period: The post-blackout period in which we can compare the model counterfactual to the observed energy usage to calculate savings. Reporting periods for efficiency projects typically last at least 365 days but may go far beyond this. For demand response, the reporting period is typically just the event day.</li> </ul>"},{"location":"documentation/history/","title":"History","text":"<p>OpenDSM's origin lies within the CalTRACK methodology. </p> <p>The CalTRACK methodology comes from a working group initiated by California Public Utility Commission (CPUC) in 2012 to track metered savings for pay-for-performance energy efficiency programs. </p> <p>The first versions were developed collaboratively by PG&amp;E and other California IOU's in conjunction with the California Energy Commission (CEC), Recurve, and other stakeholders. The goal was to develop reliable and transparent processes to calculate avoided energy use. The models that came from this process were the daily/billing models and the hourly model. The daily/billing models were heavily influenced by the Princeton Scorekeeping Method (PRISM 1986) [1]. Similarly the hourly model was an adapted version of Lawrence Berkeley National Laboratory's Time-of-Week and Temperature (TOWT) model (TOWT 2011) [2].</p> <p>The CalTRACK methodology only defined how to set up the models; it was not itself a library that users could utilize to make measurements. OpenEEmeter came in to become the open-source Python implementation of the CalTRACK methods. The changes to the models since the CalTRACK methods can be found in each model's references section. </p> <p>OpenEEmeter has since become OpenDSM to be able to include comparison groups and <code>EEweather</code>.</p> <p>Today, OpenDSM has moved beyond the CalTRACK methods. Our models are more accurate, proven in extensive testing, easier to use, and significantly faster. OpenDSM continues to evolve and develop, but all of our efforts are the result of the foundational work from those before us.</p> <p>[1] PRISM 1986: https://doi.org/10.1016/0378-7788(86)90003-4</p> <p>[2] TOWT 2011: https://doi.org/10.1109/TSG.2011.2145010</p>"},{"location":"documentation/philosophy/","title":"Philosophy","text":""},{"location":"documentation/philosophy/#model-structure","title":"Model Structure","text":"<p>Models are developed assuming that minimal information will be available for any given meter. The only assumptions made are that we will have a meter's location and usage data. Using the meter's location, its weather can be looked up using <code>EEweather</code>. This weather information can be used in place of a meter's location. </p> <p>Any additional information must be broadly available to be considered for addition into any OpenDSM models. This means that these models will inherently be statistical in nature, although informed by our engineering and domain knowledge.</p> <p>Temperature inputs are expected to be in Fahrenheit. Failure to convert your units properly can result in erroneous models.</p>"},{"location":"documentation/philosophy/#model-performance","title":"Model Performance","text":"<p>Our models must be proven with extreme rigor to be superior to the prior model that they replace to be approved for measurement purposes. </p> <p>Improvements can come in the form of global accuracy, local accuracy, replicability, API improvements, and/or computational efficiency.</p>"},{"location":"documentation/drmeter/","title":"DRmeter","text":"<p>Create short-term models fit on historical data to generate predictions of energy consumption </p>"},{"location":"documentation/drmeter/#models","title":"Models","text":""},{"location":"documentation/drmeter/#caltrack-model","title":"CalTRACK Model","text":"<p>An implementation of the time-of-week and temperature model designed to operate on short-term, hourly data.</p>"},{"location":"documentation/drmeter/#new-model","title":"New Model","text":"<p>A derivative of the OpenEEmeter hourly model. This model will be able to accurate measure solar and non-solar meters using short-term, hourly data.</p>"},{"location":"documentation/drmeter/basics/","title":"Basics","text":""},{"location":"documentation/drmeter/basics/#purpose","title":"Purpose","text":"<p>DRmeter's models are developed to predict over short periods of time. </p> <p>As an example: demand response events generally occur over the course of a few hours in a given day. To model this event, a DRmeter model might use 45 days prior to the event and 15 days after as the training period while excluding the event day.</p>"},{"location":"documentation/drmeter/basics/#error-metrics","title":"Error Metrics","text":"<p>To be completed. discuss need for normalized error metrics etc.</p>"},{"location":"documentation/drmeter/basics/#cvrmse","title":"CVRMSE","text":"<p>To be completed.</p>"},{"location":"documentation/drmeter/basics/#pnrmse","title":"PNRMSE","text":"<p>To be completed.</p>"},{"location":"documentation/drmeter/caltrack/api/","title":"API","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model","title":"<code>Model(settings=None)</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.segment_type","title":"<code>segment_type = 'single'</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.alpha","title":"<code>alpha = 0.1</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.fit","title":"<code>fit(data)</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.predict","title":"<code>predict(reporting_data)</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.to_dict","title":"<code>to_dict()</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.to_json","title":"<code>to_json()</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.Model.plot","title":"<code>plot(ax=None, title=None, figsize=None, temp_range=None)</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.BaselineData","title":"<code>BaselineData(df, is_electricity_data)</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.BaselineData.df","title":"<code>df = df</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.BaselineData.warnings","title":"<code>warnings = self._check_data_sufficiency()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.BaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.BaselineData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data)</code>  <code>classmethod</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.ReportingData","title":"<code>ReportingData(df, is_electricity_data)</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.ReportingData.df","title":"<code>df = df</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.ReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.ReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/drmeter/caltrack/api/#opendsm.drmeter.models.caltrack.ReportingData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data)</code>  <code>classmethod</code>","text":""},{"location":"documentation/drmeter/caltrack/example/","title":"Example","text":"<p>Work in Progress</p>"},{"location":"documentation/drmeter/caltrack/methodology/","title":"Methodology","text":"<p>Work in Progress</p>"},{"location":"documentation/drmeter/caltrack/references/","title":"References","text":"<ul> <li>CAISO Demand Response Report</li> <li>LBNL Time-of-Week and Temperature (TOWT) Model Paper</li> </ul>"},{"location":"documentation/drmeter/new_model/","title":"New Model","text":"<p>This model is a work in progress. </p> <p>It will be based upon the most recent OpenEEmeter hourly model (solar and non-solar).</p>"},{"location":"documentation/eemeter/","title":"OpenEEmeter","text":"<p>Create long-term models fit on historical data to generate predictions of energy consumption</p>"},{"location":"documentation/eemeter/#models","title":"Models","text":""},{"location":"documentation/eemeter/#hourly-model","title":"Hourly Model","text":"<p>A model designed to operate quickly on hourly interval data to provide accurate predictions in a reporting year.</p>"},{"location":"documentation/eemeter/#daily-model","title":"Daily Model","text":"<p>A model using daily interval data to provide accurate predictions and to be able to disaggregate daily heating and cooling loads.</p>"},{"location":"documentation/eemeter/#billing-model","title":"Billing Model","text":"<p>A modification of the daily model using billing, monthly or bimonthly, data to provide accurate annual predictions.</p>"},{"location":"documentation/eemeter/basics/","title":"Basics","text":""},{"location":"documentation/eemeter/basics/#purpose","title":"Purpose","text":"<p>OpenEEmeter's models are developed to predict over long periods of time. </p> <p>As an example: energy efficiency interventions (modifications to a building) must be measured over the course of a year because they will likely affect the energy usage during various seasons differently. An OpenEEmeter would therefore need to be trained on a baseline year (1 year prior to the change) and will predict what would have happened if the intervention never occurred (a counterfactual) for the reporting year (1 year after the change).</p>"},{"location":"documentation/eemeter/basics/#error-metrics","title":"Error Metrics","text":"<p>To be completed. discuss need for normalized error metrics etc.</p>"},{"location":"documentation/eemeter/basics/#cvrmse","title":"CVRMSE","text":"<p>To be completed.</p>"},{"location":"documentation/eemeter/basics/#pnrmse","title":"PNRMSE","text":"<p>To be completed.</p>"},{"location":"documentation/eemeter/billing_model/api/","title":"API","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel","title":"<code>BillingModel(settings=None, verbose=False)</code>","text":"<p>A class to fit a model to the input meter data.</p> <p>BillingModel is a wrapper for the DailyModel class using billing presets.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of settings.</p> <code>seasonal_options</code> <code>list</code> <p>A list of seasonal options (su: Summer, sh: Shoulder, wi: Winter). Elements in the list are seasons separated by '_' that represent a model split. For example, a list of ['su_sh', 'wi'] represents two splits: summer/shoulder and winter.</p> <code>day_options</code> <code>list</code> <p>A list of day options.</p> <code>combo_dictionary</code> <code>dict</code> <p>A dictionary of combinations.</p> <code>df_meter</code> <code>DataFrame</code> <p>A dataframe of meter data.</p> <code>error</code> <code>dict</code> <p>A dictionary of error metrics.</p> <code>combinations</code> <code>list</code> <p>A list of combinations.</p> <code>components</code> <code>list</code> <p>A list of components.</p> <code>fit_components</code> <code>list</code> <p>A list of fit components.</p> <code>wRMSE_base</code> <code>float</code> <p>The mean bias error for no splits.</p> <code>best_combination</code> <code>list</code> <p>The best combination of splits.</p> <code>model</code> <code>Pipeline</code> <p>The final fitted model.</p> <code>id</code> <code>str</code> <p>The index of the meter data.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.seasonal_options","title":"<code>seasonal_options = [['su_sh_wi'], ['su', 'sh_wi'], ['su_sh', 'wi'], ['su_wi', 'sh'], ['su', 'sh', 'wi']]</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.day_options","title":"<code>day_options = [['wd', 'we']]</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.combo_dictionary","title":"<code>combo_dictionary = {'su': 'summer', 'sh': 'shoulder', 'wi': 'winter', 'fw': [n + 1 for n in n_week], 'wd': [n + 1 for n in n_week if day_dict[n + 1] == 'weekday'], 'we': [n + 1 for n in n_week if day_dict[n + 1] == 'weekend']}</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.to_json","title":"<code>to_json()</code>","text":"<p>Returns a JSON string of model parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>Model parameters.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a instance of the class from a dictionary (such as one produced from the to_dict method).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the model data.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string representing the object.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.from_2_0_dict","title":"<code>from_2_0_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a legacy (2.0) model dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the necessary data (legacy 2.0) to create a DailyModel instance.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.from_2_0_json","title":"<code>from_2_0_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a legacy (2.0) JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.fit","title":"<code>fit(baseline_data, ignore_disqualification=False)</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.predict","title":"<code>predict(reporting_data, aggregation=None, ignore_disqualification=False)</code>","text":"<p>Predicts the energy consumption using the fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>reporting_data</code> <code>BillingBaselineData | BillingReportingData</code> <p>The data used for prediction.</p> required <code>aggregation</code> <code>str | None</code> <p>The aggregation level for the prediction. One of [None, 'none', 'monthly', 'bimonthly'].</p> <code>None</code> <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore model disqualification. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with input data along with predicted energy consumption.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the model is not fitted.</p> <code>DisqualifiedModelError</code> <p>If the model is disqualified and ignore_disqualification is False.</p> <code>TypeError</code> <p>If the reporting data is not of type BillingBaselineData or BillingReportingData.</p> <code>ValueError</code> <p>If the aggregation is not one of [None, 'none', 'monthly', 'bimonthly'].</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.plot","title":"<code>plot(data, aggregation=None)</code>","text":"<p>Plot a model fit with baseline or reporting data. Requires matplotlib to use.</p> <p>Parameters:</p> Name Type Description Default <code>df_eval</code> <p>The baseline or reporting data object to plot.</p> required <code>aggregation</code> <code>str | None</code> <p>The aggregation level for the prediction. One of [None, 'none', 'monthly', 'bimonthly'].</p> <code>None</code>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Model parameters.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData","title":"<code>BillingBaselineData(df, is_electricity_data, settings=None)</code>","text":"<p>Data class to represent Billing Baseline Data.</p> <p>Only baseline data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Billing data should have an extra month's data appended at the to denote end of period. (Do not append NaN, any other value would work.)</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of ssues with the data, but none that will severely reduce the quality of the model built.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.settings","title":"<code>settings = self._settings_class()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.billing_df","title":"<code>billing_df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data, settings=None)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p> <p>Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe. The temperature column should have values in Fahrenheit.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame</code> <p>The meter data.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data.</p> required <code>is_electricity_data</code> <code>bool</code> <p>A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.</p> required <p>Returns:</p> Type Description <p>An instance of the Data class with the dataframe populated with the corrected data, along with warnings and disqualifications based on the input.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingBaselineData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> <p>View the disqualifications and warnings associated with the current data input provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData","title":"<code>BillingReportingData(df, is_electricity_data, settings=None)</code>","text":"<p>Data class to represent Billing Reporting Data.</p> <p>Only reporting data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Meter data input is optional for the reporting class.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of ssues with the data, but none that will severely reduce the quality of the model built.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.settings","title":"<code>settings = self._settings_class()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.billing_df","title":"<code>billing_df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> <p>View the disqualifications and warnings associated with the current data input provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"documentation/eemeter/billing_model/api/#opendsm.eemeter.models.billing.BillingReportingData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data, tzinfo=None, settings=None)</code>  <code>classmethod</code>","text":"<p>Create a BillingReportingData instance from meter data and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame | None</code> <p>The meter data to be used for the BillingReportingData instance.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data to be used for the BillingReportingData instance.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag indicating whether the meter data represents electricity data.</p> required <code>tzinfo</code> <code>tzinfo | None</code> <p>Timezone information to be used for the meter data.</p> <code>None</code> <p>Returns:</p> Type Description <p>An instance of the Data class.</p>"},{"location":"documentation/eemeter/billing_model/example/","title":"Example","text":"<p>In this example, we'll walk through creating a Daily Model and predicting usage with it.</p> <p>You can find a working example in the Example Code at the bottom of the page.</p> <p> 1) This example makes use of Matplotlib. Matplotlib is not a required dependency of OpenDSM. 2) If you run this example, it will download up to 150 MB of example data from the GitHub repo. </p>"},{"location":"documentation/eemeter/billing_model/example/#imports","title":"Imports","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport opendsm as odsm\nfrom opendsm import eemeter as em\n</code></pre>"},{"location":"documentation/eemeter/billing_model/example/#loading-data","title":"Loading data","text":"<p>The essential inputs to OpenDSM library functions are the following:</p> <ol> <li>Meter baseline data named <code>observed</code></li> <li>Meter reporting data <code>observed</code></li> <li>Temperature data from a nearby weather station for both named <code>temperature</code></li> <li>All data is expected to have a timezone-aware datetime index or column named <code>datetime</code></li> </ol> <p>Users of the library are responsible for obtaining and formatting this data (to get weather data, see EEweather, which helps perform site to weather station matching and can pull and cache temperature data directly from public (US) data sources).</p> <p>We utilize data classes to store meter data, perform transforms, and validate the data to ensure data compliance. The inputs into these data classes can either be pandas <code>DataFrame</code> if initializing the classes directly or <code>Series</code> if initializing the classes using <code>.from_series</code>.</p> <p>The test data contained within the OpenDSM library is derived from NREL ComStock simulations.</p> <p>If working with your own data instead of these samples, please refer directly to the excellent pandas documentation for instructions for loading data (e.g., pandas.read_csv).</p>"},{"location":"documentation/eemeter/billing_model/example/#important-notes-about-data","title":"Important notes about data","text":"<ul> <li>These models were developed and tested using Fahrenheit temperature. Please convert your temperatures accordingly</li> <li>It is expected that all data is trimmed to its appropriate time period (baseline and reporting) and does not contain extraneous datetimes</li> </ul> <p>Let us begin by loading some example data. Here we use a built-in utility function to load some example data.</p> <p>This function returns two dataframes of daily electricity data, one for the baseline period and one for the reporting period.</p> <pre><code>df_baseline, df_reporting =  odsm.test_data.load_test_data(\"daily_treatment_data\")\n</code></pre> <p>If we inspect these dataframes, we will notice that there are 100 meters for you to experiment with, indexed by meter id and datetime.</p> <pre><code>print(df_baseline)\n</code></pre> Returns <pre><code>id      datetime                    temperature observed\n108618  2018-01-01 00:00:00-06:00   -2.384038   16635.193673\n        2018-01-02 00:00:00-06:00   1.730000    15594.051162\n        2018-01-03 00:00:00-06:00   13.087946   11928.025899\n        2018-01-04 00:00:00-06:00   4.743269    14399.333812\n        2018-01-05 00:00:00-06:00   4.130577    14315.101721\n... ... ... ...\n120841  2018-12-27 00:00:00-06:00   52.010625   1153.749811\n        2018-12-28 00:00:00-06:00   35.270000   1704.076968\n        2018-12-29 00:00:00-06:00   29.630000   2151.225729\n        2018-12-30 00:00:00-06:00   34.250000   1331.123954\n        2018-12-31 00:00:00-06:00   43.311250   1723.397349\n</code></pre> <p>To simplify things, we will filter down to a single meter for the rest of the example. Let's filter down to the 15th id.</p> <pre><code>n = 15\n\nid = df_baseline.index.get_level_values(0).unique()[n]\n\ndf_baseline_n = df_baseline.loc[id]\ndf_reporting_n = df_reporting.loc[id]\n</code></pre> <p>If we inspect one of these dataframes, we will now notice that only a single meter is present with 365 days of data in each dataframe. </p> <pre><code>print(df_baseline_n)\n</code></pre> Returns <pre><code>                           temperature     observed\ndatetime                                           \n2018-01-01 00:00:00-06:00   -10.045000  9629.679232\n2018-01-02 00:00:00-06:00    -4.712500  8868.878051\n2018-01-03 00:00:00-06:00    11.352500  6109.322326\n2018-01-04 00:00:00-06:00     0.972500  7557.067633\n2018-01-05 00:00:00-06:00     3.147500  6650.189107\n...                                ...          ...\n2018-12-27 00:00:00-06:00    46.760000  2675.234259\n2018-12-28 00:00:00-06:00    35.323125  3561.451294\n2018-12-29 00:00:00-06:00    26.386250  3247.215055\n2018-12-30 00:00:00-06:00    28.463750  3048.525124\n2018-12-31 00:00:00-06:00    40.345250  3226.933132\n</code></pre> <p>Also notice the general structure of these dataframes for a single meter. We have three columns:</p> <ol> <li>A timezone-aware datetime index.</li> <li>A temperature column (float) in Fahrenheit (be sure to convert any other units to Fahrenheit first).</li> <li>Observed meter usage (float). The example here is electricity data in kWh, but it could also be gas data.</li> </ol> <p>We can stop to plot this data to get a better understanding of the general behavior of this meter. <pre><code>ax = df_baseline_n['observed'].plot(label='Observed Usage', color='blue')\ndf_baseline_n['temperature'].plot(ax=ax, secondary_y=True, label='Temperature (F)', color='orange')\n\nax.set_ylabel('Observed Usage (kWh)')\nax.right_ax.set_ylabel('Temperature (F)')\n\nax.legend(loc='upper left')\nax.right_ax.legend(loc='upper right')\n\nplt.title('Observed Usage and Temperature in the Baseline Period')\nplt.show()\n</code></pre></p> Returns <p> </p> <p>If we observe the data we can see a full year of data with observed usage peaking in the winter and lowering in the summer with warmer temperatures. It's clear that this site is located in a colder climate and uses more electricity in the winter.</p>"},{"location":"documentation/eemeter/billing_model/example/#loading-data-into-eemeter-data-objects","title":"Loading Data into EEmeter Data Objects","text":"<p>With our sample data loaded into dataframes, we can create our Baseline and Reporting Data objects. Note that only the baseline period is needed to fit a model, but we will use our reporting period data to predict against.</p> <pre><code>baseline_data = em.DailyBaselineData(df_baseline_n, is_electricity_data=True)\nreporting_data = em.DailyReportingData(df_reporting_n, is_electricity_data=True)\n</code></pre> <p>These classes are critical to ensure standardized data loaded into the model. These classes also scan the data to check for data sufficiency and other criteria that might cause a model to be disqualified (unable to build a model of sufficient integrity).</p> <p>As a note, you can also instantiate these data classes with two separate meter usage and temperature Series objects, both indexed by timezone-aware datetime.</p> Example <pre><code>baseline_data = em.DailyBaselineData.from_series(df_baseline_n['observed'], df_baseline_n['temperature'], is_electricity_data=True)\n</code></pre> <p>With data classes successfully instantiated, we can also check for any disqualifications or warnings before moving on to the model fitting step.</p> <pre><code>print(f\"Disqualifications: {baseline_data.disqualification}\")\nprint(f\"Warnings:          {baseline_data.warnings}\")\n</code></pre> Returns <pre><code>Disqualifications: []\nWarnings:          [EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.unable_to_confirm_daily_temperature_sufficiency), \n                    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.extreme_values_detected)]\n</code></pre> <p>From this, we can see that no disqualifications are present but there are some warnings to be aware of as we proceed. Neither of these warnings will necessarily stop us from creating a model.</p> <p>Before we move on, also notice that you can access the underlying dataframe in each object like follows to see exactly what will be loaded into the model.</p> <pre><code>print(baseline_data.df.head())\n</code></pre> Returns <pre><code>datetime                    season  weekday_weekend temperature observed\n2018-01-01 00:00:00-06:00   winter  weekday         -10.0450    9629.7\n2018-01-02 00:00:00-06:00   winter  weekday         -4.7125     8868.9\n2018-01-03 00:00:00-06:00   winter  weekday         11.3525     6109.3\n2018-01-04 00:00:00-06:00   winter  weekday         0.9725      7557.1\n2018-01-05 00:00:00-06:00   winter  weekday         3.1475      6650.2\n</code></pre>"},{"location":"documentation/eemeter/billing_model/example/#creating-the-model","title":"Creating the Model","text":"<p>The daily model follows the general process of: 1. Initialize 2. Fit 3. Predict</p> <p>We can do this easily as follows:</p> <pre><code>daily_model = em.DailyModel()\ndaily_model.fit(baseline_data)\n</code></pre> <p>Before we move to predicting against a dataframe, we can actually use the built in plot function (requiring matplotlib) to plot the performance of the model against the provided data.</p> <pre><code>daily_model.plot(baseline_data)\n</code></pre> Returns <p> </p> <p>From this graph we can also observe model splits and model types as described in the Model Splits section of the Methodology page. We can observe the following models:</p> <ol> <li>Summer/Shoulder/Winter - Weekday</li> <li>Summer/Shoulder/Winter - Weekend</li> </ol> <p>This illustrates that the weekends are different enough to warrant their own model compared to the weekdays. Each meter is treated separately and will be given its own unique splits if justified by the data. All of this complexity is handled under the hood, and the model will utilize the correct model when predicting usage automatically.</p> <p>We can also use this function to plot the model prediction against the reporting period as follows:</p> <pre><code>daily_model.plot(reporting_data)\n</code></pre> Returns <p> </p> <p>In this plot we can see that the site is using significantly less energy in colder temperatures compared to the model / baseline period. Perhaps this site installed an efficiency intervention that saves energy in colder temperatures?</p>"},{"location":"documentation/eemeter/billing_model/example/#predicting-with-the-model-and-calculating-savings","title":"Predicting with the Model and Calculating Savings","text":"<p>With our fit model, we can now predict across a given reporting period as follows:</p> <pre><code>df_results = daily_model.predict(reporting_data)\nprint(df_results.head())\n</code></pre> Returns <pre><code>datetime                    season  day_of_week weekday_weekend  temperature observed     predicted    predicted_unc  heating_load  cooling_load  model_split  model_type                                                  \n2019-01-01 00:00:00-06:00  winter            2         weekday     -10.0450  6821.633670  8458.769369     403.385708   6145.    508305           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-02 00:00:00-06:00  winter            3         weekday      -4.7125  5668.980225  7829.167990     403.385708   5515.    906926           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-03 00:00:00-06:00  winter            4         weekday      11.3525  3122.794390  5960.086410     403.385708   3646.    825346           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-04 00:00:00-06:00  winter            5         weekday       0.9725  3880.896300  7161.729548     403.385708   4848.    468484           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-05 00:00:00-06:00  winter            6         weekend       3.1475  3182.209058  5213.370264     285.516312   3858.    054437           0.0  we-su_sh_wi  hdd_tidd_cdd_smooth\n</code></pre> <p>We can also plot the observed usage vs. the predicted usage.</p> <pre><code>ax = df_results['observed'].plot(label='Observed Usage', color='blue')\ndf_results['predicted'].plot(ax=ax, label='Predicted Usage', color='orange')\n\nax.set_ylabel('Observed Usage (kWh)')\nax.legend(loc='upper left')\nplt.title('Observed Usage and Temperature in the Baseline Period')\nplt.show()\n</code></pre> Returns <p> </p> <p>From here, we can easily calculate savings by subtracting observed usage from predicted usage.</p> <pre><code>df_results['savings'] = df_results['predicted'] - df_results['observed']\nprint(f\"Predicted Usage (kWh):  {round(df_results['predicted'].sum(), 2)}\")\nprint(f\"Observed Usage (kWh):   {round(df_results['observed'].sum(), 2)}\")\nprint(f\"Savings (kWh):          {round(df_results['savings'].sum(), 2)}\")\n</code></pre> Returns <pre><code>Predicted Usage (kWh):  1038465.06\nObserved Usage (kWh):   789252.05\nSavings (kWh):          249213.01\n</code></pre>"},{"location":"documentation/eemeter/billing_model/example/#model-serialization","title":"Model Serialization","text":"<p>After creating a model, we can also serialize it for storage and read it back in later.</p> <pre><code>saved_model = daily_model.to_json()\nprint(saved_model)\n</code></pre> Returns <pre><code>{\"submodels\": {\"wd-su_sh_wi\": {\"coefficients\": {\"model_type\": \"hdd_tidd_cdd_smooth\", \"intercept\": 2313.2610638676033, \"hdd_bp\": 41.27040090608855, \"hdd_beta\": 119.44918113103105, \"hdd_k\": 0.4726274184833831, \"cdd_bp\": 70.96439586012724, \"cdd_beta\": 64.46865583811494, \"cdd_k\": 0.17605359829111333}, \"temperature_constraints\": {\"T_min\": -10.045, \"T_max\": 83.00500000000001, \"T_min_seg\": 8.94425, \"T_max_seg\": 81.38}, \"f_unc\": 403.3857082521867}, \"we-su_sh_wi\": {\"coefficients\": {\"model_type\": \"hdd_tidd_cdd_smooth\", \"intercept\": 1355.3158273422803, \"hdd_bp\": 50.8894292209749, \"hdd_beta\": 80.73766873918538, \"hdd_k\": 0.4482831249857758, \"cdd_bp\": 74.53352300727671, \"cdd_beta\": 41.0269706642773, \"cdd_k\": 0.5237054341526147}, \"temperature_constraints\": {\"T_min\": -2.7850000000000015, \"T_max\": 82.34, \"T_min_seg\": 22.4675, \"T_max_seg\": 79.7525}, \"f_unc\": 285.5163122905078}}, \"info\": {\"metrics\": {\"num_model_params\": 14, \"wrmse\": 218.75309123080092, \"n\": 365, \"n_prime\": 125.66853004788871, \"ddof\": 351, \"ddof_autocorr\": 111.66853004788871, \"observed\": {\"sum\": 1038753.15993621, \"mean\": 2845.899068318384, \"variance\": 1143760.7395673955, \"std\": 1069.4675028103452, \"cvstd\": 0.37579249198120157, \"sum_squared\": 3373659320.017336, \"median\": 2697.2358494980817, \"MAD_scaled\": 602.7295755197579, \"iqr\": 953.5552891155535, \"skew\": 2.221492866364899, \"kurtosis\": 9.332585130726638}, \"predicted\": {\"sum\": 1038740.3421026455, \"mean\": 2845.863950966152, \"variance\": 1074489.9131218037, \"std\": 1036.5760527437453, \"cvstd\": 0.3642394965479058, \"sum_squared\": 3348302512.293626, \"median\": 2627.7907614770256, \"MAD_scaled\": 464.5595323515464, \"iqr\": 914.7262255954338, \"skew\": 1.616695269464077, \"kurtosis\": 4.280790657230931}, \"residuals\": {\"sum\": 12.81783356446158, \"mean\": 0.03511735223140159, \"variance\": 47852.91368980268, \"std\": 218.7530884120329, \"cvstd\": 6229.202218054072, \"sum_squared\": 17466313.946906358, \"median\": 11.83559927083752, \"MAD_scaled\": 113.71324840144126, \"iqr\": 154.18635619428915, \"skew\": 1.3547762272723773, \"kurtosis\": 15.583344758089789}, \"max_error\": 1593.5483136788926, \"mae\": 126.71422886475526, \"nmae\": 0.044525201288895165, \"pnmae\": 0.13288608464673915, \"medae\": 76.1375240548914, \"mbe\": 0.03511735223140159, \"nmbe\": 1.233963376366405e-05, \"pnmbe\": 3.682780918133632e-05, \"sse\": 17466313.946906358, \"mse\": 47852.914923031116, \"rmse\": 218.75309123080092, \"rmse_autocorr\": 372.8098372555297, \"rmse_adj\": 223.07303332387448, \"rmse_autocorr_adj\": 395.4897491902344, \"cvrmse\": 0.07686607500105763, \"cvrmse_autocorr\": 0.1309989666906282, \"cvrmse_adj\": 0.07838402837514766, \"cvrmse_autocorr_adj\": 0.1389682977843363, \"pnrmse\": 0.22940787359451376, \"pnrmse_autocorr\": 0.39096824432836, \"pnrmse_adj\": 0.23393822662425828, \"pnrmse_autocorr_adj\": 0.41475282419864834, \"r_squared\": 0.9582550959309059, \"r_squared_adj\": 0.9565852997681421, \"mape\": 0.04085618887177056, \"smape\": 0.04056430298847941, \"wape\": 0.04452520128889517, \"swape\": 0.04452547600292869, \"maape\": 0.04074758380763742, \"nse\": 0.9581617787115769, \"nnse\": 0.9598419212949566, \"kge\": 0.9627155493651588, \"a10\": 0.9178082191780822, \"a20\": 0.9972602739726028, \"a30\": 1.0, \"wi\": 0.9890978278885424, \"index_of_agreement\": 0.9106627590653706, \"pearson_r\": 0.9789050494970932, \"pi\": 0.968232858166701, \"pi_rating\": \"excellent\", \"explained_variance_score\": 0.9581617797897993}, \"baseline_timezone\": \"America/Chicago\", \"disqualification\": [], \"warnings\": [{\"qualified_name\": \"eemeter.sufficiency_criteria.extreme_values_detected\", \"description\": \"Extreme values (outside 3x IQR) must be flagged for manual review.\", \"data\": {\"n_extreme_values\": 8, \"median\": 2697.2358494980817, \"upper_quantile\": 3269.296428540127, \"lower_quantile\": 2315.7411394245737, \"lower_bound\": -544.9247279220867, \"upper_bound\": 6129.962295886788, \"min_value\": 1181.0132889040156, \"max_value\": 9629.679232340746}}]}, \"settings\": {\"developer_mode\": false, \"algorithm_choice\": \"nlopt_sbplx\", \"initial_guess_algorithm_choice\": \"nlopt_direct\", \"full_model\": \"hdd_tidd_cdd\", \"allow_smooth_model\": true, \"alpha_minimum\": -100, \"alpha_selection\": 2, \"alpha_final_type\": \"last\", \"alpha_final\": \"adaptive\", \"final_bounds_scalar\": 1, \"regularization_alpha\": 0.001, \"regularization_percent_lasso\": 1, \"segment_minimum_count\": 6, \"maximum_slope_oom_scalar\": 2, \"initial_step_percentage\": 0.1, \"split_selection\": {\"criteria\": \"bic\", \"penalty_multiplier\": 0.24, \"penalty_power\": 2.061, \"allow_separate_summer\": true, \"allow_separate_shoulder\": true, \"allow_separate_winter\": true, \"allow_separate_weekday_weekend\": true, \"reduce_splits_by_gaussian\": true, \"reduce_splits_num_std\": [1.4, 0.89]}, \"season\": {\"january\": \"winter\", \"february\": \"winter\", \"march\": \"shoulder\", \"april\": \"shoulder\", \"may\": \"shoulder\", \"june\": \"summer\", \"july\": \"summer\", \"august\": \"summer\", \"september\": \"summer\", \"october\": \"shoulder\", \"november\": \"winter\", \"december\": \"winter\", \"options\": [\"summer\", \"shoulder\", \"winter\"]}, \"weekday_weekend\": {\"monday\": \"weekday\", \"tuesday\": \"weekday\", \"wednesday\": \"weekday\", \"thursday\": \"weekday\", \"friday\": \"weekday\", \"saturday\": \"weekend\", \"sunday\": \"weekend\", \"options\": [\"weekday\", \"weekend\"]}, \"uncertainty_alpha\": 0.1, \"cvrmse_threshold\": 1, \"pnrmse_threshold\": 1.6}}\n</code></pre> <p>Afterwards, we can instantiate the model as follows:</p> <pre><code>loaded_model = em.DailyModel.from_json(saved_model)\n</code></pre>"},{"location":"documentation/eemeter/billing_model/example/#automatic-sufficiency-checking","title":"Automatic Sufficiency Checking","text":"<p>Two of the core features of the OpenDSM Data and Model classes are automatic data sufficiency and model sufficiency checking. This ensures that only acceptable data and models are allowed to be used for making measurements. Let's show an example of how this works by introducing too many NaN values into the observed data of the prior example.</p> <pre><code>daily_baseline_data_DQ = em.DailyBaselineData.from_series(\n    meter_data = df_baseline_n[\"observed\"], \n    temperature_data = df_baseline_n[\"temperature\"],\n    is_electricity_data=True\n    )\n\n# set rows 1:38 of observed to nan\ndf_baseline_n = daily_baseline_data_DQ.df\ndf_baseline_n.loc[df_baseline_n.index[1:37], \"observed\"] = np.nan\n\ndaily_baseline_data_DQ = em.DailyBaselineData(df_baseline_n, is_electricity_data=True)\nprint(f\"Disqualifications: {daily_baseline_data_DQ.disqualification}\")\n</code></pre> Returns <pre><code>Disqualifications: [\n    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.too_many_days_with_missing_observed_data), \n    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.too_many_days_with_missing_joint_data)\n]\n</code></pre> <p>If this data were to try to be fit on it would return an error by default.</p> <pre><code>try:\n    daily_model = em.DailyModel().fit(daily_baseline_data_DQ)\nexcept Exception as e:\n    print(f\"Exception: {e}\")\n</code></pre> Returns <pre><code>Exception: Can't fit model on disqualified baseline data\n</code></pre> <p>In some circumstances it may still be possible to fit a model on disqualified data for investigative purposes. This can be done by setting the <code>ignore_disqualification</code> flag to True.</p> <pre><code>daily_model = em.DailyModel().fit(daily_baseline_data_DQ, ignore_disqualification=True)\n</code></pre> <p>Please remember that enabling <code>ignore_disqualification</code> or making any changes to the model configuration fundamentally alters the model and such models are not approved for measurement purposes.</p>"},{"location":"documentation/eemeter/billing_model/example/#example-code","title":"Example Code","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport opendsm as odsm\nfrom opendsm import eemeter as em\n\ndf_baseline, df_reporting =  odsm.test_data.load_test_data(\"daily_treatment_data\")\n\nn = 15\n\nid = df_baseline.index.get_level_values(0).unique()[n]\n\ndf_baseline_n = df_baseline.loc[id]\ndf_reporting_n = df_reporting.loc[id]\n\nbaseline_data = em.DailyBaselineData(df_baseline_n, is_electricity_data=True)\nreporting_data = em.DailyReportingData(df_reporting_n, is_electricity_data=True)\n\nprint(f\"Disqualifications: {baseline_data.disqualification}\")\nprint(f\"Warnings:          {baseline_data.warnings}\")\n\ndaily_model = em.DailyModel()\ndaily_model.fit(baseline_data)\n\n# Save model to json\nsaved_model = daily_model.to_json()\nloaded_model = em.DailyModel.from_json(saved_model)\n\n# Model results\ndaily_model.plot(baseline_data)\ndaily_model.plot(reporting_data)\n\ndf_results = daily_model.predict(reporting_data)\ndf_results['savings'] = df_results['predicted'] - df_results['observed']\nprint(f\"Predicted Usage (kWh):  {round(df_results['predicted'].sum(), 2)}\")\nprint(f\"Observed Usage (kWh):   {round(df_results['observed'].sum(), 2)}\")\nprint(f\"Savings (kWh):          {round(df_results['savings'].sum(), 2)}\")\n</code></pre>"},{"location":"documentation/eemeter/billing_model/methodology/","title":"Methodology","text":"<p>The billing model uses the daily model with some slight configuration changes and uses billing (monthly or bimonthly) interval data.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#model-theory","title":"Model Theory","text":""},{"location":"documentation/eemeter/billing_model/methodology/#converting-from-billing-data-to-daily-data","title":"Converting from billing data to daily data","text":"<p>The billing model intakes billing data and calculates the average energy usage for each given period. For example if a bill covers 31 days and uses 93 therms total, then each day would be given 3 therms of usage. Pulling the temperature from <code>EEweather</code> ensures that each day's mean temperature is correct.</p> <p>From here, the data is treated as daily interval data and uses the daily model internally.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#model-shape-and-balance-points","title":"Model Shape and Balance Points","text":"<p>The daily model, at its core, utilizes a piecewise linear regression model that predicts energy usage relative to temperature. The model determines temperature balance points at which energy usage starts changing relative to temperature.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#key-concepts","title":"Key Concepts","text":"<ul> <li>Balance Points: Outdoor temperature thresholds beyond which heating and cooling effects are observed.</li> <li>Heating and Cooling Coefficients: Rate of increase of energy use per change in temperature beyond the balance points.</li> <li>Temperature Independent Load: The regression intercept (height of the flat line in the diagram).</li> <li>Billing Data: Because the billing data is converted to daily data, plots will show lines of data points where the usage is the same over a range of temperatures seen during that period.</li> </ul>"},{"location":"documentation/eemeter/billing_model/methodology/#model-archetypes","title":"Model Archetypes","text":"<p>Based on the site behavior, there are four different model types that may be generated:</p> <ul> <li>Heating and Cooling Loads</li> <li>Heating Only Load</li> <li>Cooling Only Load</li> <li>Temperature Independent Load</li> </ul>"},{"location":"documentation/eemeter/billing_model/methodology/#smooth-transitions","title":"Smooth Transitions","text":"<p>The billing model disables this feature.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#robust-adaptive-outlier-downweighting","title":"Robust, Adaptive Outlier Downweighting","text":"<p>The billing model disables this feature.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#model-fit","title":"Model Fit","text":"<p>When the model is fit, each site will receive its own unique model fit and coefficients. The general model fitting process is as follows:</p> <ol> <li>Balance points are estimated with a global optimization algorithm.</li> <li>Sum of Squares Error (SSE) is minimized with Lasso regression inspired penalization.</li> <li>The best model type is determined (ex. cooling load only model) using the penalized SSE.</li> </ol> <p>The Lasso inspired penalization means that increased model complexity must be justified by decreased SSE and balanced against these general rules:</p> <ul> <li>Slopes are pushed to 0</li> <li>Intercept is pushed to 0</li> <li>Balance points are pushed together</li> <li>Balance points are pushed towards the nearest edge (most extreme temperature)</li> </ul> <p>At this point the billing model is now fit and can be used for prediction.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#model-splits","title":"Model Splits","text":"<p>Unlike the standard daily model, the billing model is configured to not allow splits. There is not enough information to make these distinctions.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#real-data-example","title":"Real Data Example","text":"<p>Here are 6 examples of how the billing model performs on real data.</p> <p>*For additional information and validation details, see the References page.</p>"},{"location":"documentation/eemeter/billing_model/methodology/#sufficiency-criteria","title":"Sufficiency Criteria","text":"<p>To be completed</p>"},{"location":"documentation/eemeter/billing_model/references/","title":"References","text":"<p>If embedded pdf viewer fails to load, click here.</p>"},{"location":"documentation/eemeter/daily_model/api/","title":"API","text":"<p>example:</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel","title":"<code>DailyModel(model='current', settings=None, verbose=False)</code>","text":"<p>A class to fit a model to the input meter data.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of settings.</p> <code>seasonal_options</code> <code>list</code> <p>A list of seasonal options (su: Summer, sh: Shoulder, wi: Winter). Elements in the list are seasons separated by '_' that represent a model split. For example, a list of ['su_sh', 'wi'] represents two splits: summer/shoulder and winter.</p> <code>day_options</code> <code>list</code> <p>A list of day options.</p> <code>combo_dictionary</code> <code>dict</code> <p>A dictionary of combinations.</p> <code>df_meter</code> <code>DataFrame</code> <p>A dataframe of meter data.</p> <code>error</code> <code>dict</code> <p>A dictionary of error metrics.</p> <code>combinations</code> <code>list</code> <p>A list of combinations.</p> <code>components</code> <code>list</code> <p>A list of components.</p> <code>fit_components</code> <code>list</code> <p>A list of fit components.</p> <code>wRMSE_base</code> <code>float</code> <p>The mean bias error for no splits.</p> <code>best_combination</code> <code>list</code> <p>The best combination of splits.</p> <code>model</code> <code>Pipeline</code> <p>The final fitted model.</p> <code>id</code> <code>str</code> <p>The index of the meter data.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use (either 'current' or 'legacy').</p> <code>'current'</code> <code>settings</code> <code>dict | None</code> <p>DailySettings to be changed.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output.</p> <code>False</code>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.fit","title":"<code>fit(baseline_data, ignore_disqualification=False)</code>","text":"<p>Fit the model using baseline data.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_data</code> <code>DailyBaselineData</code> <p>DailyBaselineData object.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore disqualification errors / warnings.</p> <code>False</code> <p>Returns:</p> Type Description <code>DailyModel</code> <p>The fitted model.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If baseline_data is not a DailyBaselineData object.</p> <code>DataSufficiencyError</code> <p>If the model can't be fit on disqualified baseline data.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.predict","title":"<code>predict(reporting_data, ignore_disqualification=False)</code>","text":"<p>Predicts the energy consumption using the fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>reporting_data</code> <code>Union[DailyBaselineData, DailyReportingData]</code> <p>The data used for prediction.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore model disqualification. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with input data along with predicted energy consumption.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the model is not fitted.</p> <code>DisqualifiedModelError</code> <p>If the model is disqualified and ignore_disqualification is False.</p> <code>ValueError</code> <p>If the reporting data has a different timezone than the model.</p> <code>TypeError</code> <p>If the reporting data is not of type DailyBaselineData or DailyReportingData.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Model parameters.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.to_json","title":"<code>to_json()</code>","text":"<p>Returns a JSON string of model parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>Model parameters.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a instance of the class from a dictionary (such as one produced from the to_dict method).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the model data.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string representing the object.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyModel.plot","title":"<code>plot(data)</code>","text":"<p>Plot a model fit with baseline or reporting data. Requires matplotlib to use.</p> <p>Parameters:</p> Name Type Description Default <code>df_eval</code> <p>The baseline or reporting data object to plot.</p> required"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.utilities.settings.DailySettings","title":"<code>DailySettings</code>","text":"<p>Settings for creating the daily model.</p> <p>These settings should be converted to a dictionary before being passed to the DailyModel class. Be advised that any changes to the default settings deviates from OpenEEmeter standard methods and should be used with caution.</p> <p>Attributes:</p> Name Type Description <code>developer_mode</code> <code>bool</code> <p>Allows changing of developer settings</p> <code>algorithm_choice</code> <code>str</code> <p>Optimization algorithm choice. Developer mode only.</p> <code>initial_guess_algorithm_choice</code> <code>str</code> <p>Initial guess optimization algorithm choice. Developer mode only.</p> <code>full_model</code> <code>str</code> <p>The largest model allowed. Developer mode only.</p> <code>smoothed_model</code> <code>bool</code> <p>Allow smoothed models.</p> <code>allow_separate_summer</code> <code>bool</code> <p>Allow summer to be modeled separately.</p> <code>allow_separate_shoulder</code> <code>bool</code> <p>Allow shoulder to be modeled separately.</p> <code>allow_separate_winter</code> <code>bool</code> <p>Allow winter to be modeled separately.</p> <code>allow_separate_weekday_weekend</code> <code>bool</code> <p>Allow weekdays and weekends to be modeled separately.</p> <code>reduce_splits_by_gaussian</code> <code>bool</code> <p>Reduces splits by fitting with multivariate Gaussians and testing for overlap.</p> <code>reduce_splits_num_std</code> <code>list[float]</code> <p>Number of standard deviations to use with Gaussians.</p> <code>alpha_minimum</code> <code>float</code> <p>Alpha where adaptive robust loss function is Welsch loss.</p> <code>alpha_selection</code> <code>float</code> <p>Specified alpha to evaluate which is the best model type.</p> <code>alpha_final_type</code> <code>str</code> <p>When to use 'alpha_final: 'all': on every model, 'last': on final model, 'None': don't use.</p> <code>alpha_final</code> <code>float | str | None</code> <p>Specified alpha or 'adaptive' for adaptive loss in model evaluation.</p> <code>final_bounds_scalar</code> <code>float | None</code> <p>Scalar for calculating bounds of 'alpha_final'.</p> <code>regularization_alpha</code> <code>float</code> <p>Alpha for elastic net regularization.</p> <code>regularization_percent_lasso</code> <code>float</code> <p>Percent lasso vs (1 - perc) ridge regularization.</p> <code>segment_minimum_count</code> <code>int</code> <p>Minimum number of data points for HDD/CDD.</p> <code>maximum_slope_OoM_scalar</code> <code>float</code> <p>Scaler for initial slope to calculate bounds based on order of magnitude.</p> <code>initial_smoothing_parameter</code> <code>float | None</code> <p>Initial guess for the smoothing parameter.</p> <code>initial_step_percentage</code> <code>float | None</code> <p>Initial step-size for relevant algorithms.</p> <code>split_selection_criteria</code> <code>str</code> <p>What selection criteria is used to select data splits of models.</p> <code>split_selection_penalty_multiplier</code> <code>float</code> <p>Penalty multiplier for split selection criteria.</p> <code>split_selection_penalty_power</code> <code>float</code> <p>What power should the penalty of the selection criteria be raised to.</p> <code>season</code> <code>Dict[int, str]</code> <p>Dictionary of months and their associated season (January is 1).</p> <code>is_weekday</code> <code>Dict[int, bool]</code> <p>Dictionary of days (1 = Monday) and if that day is a weekday (True/False).</p> <code>uncertainty_alpha</code> <code>float</code> <p>Significance level used for uncertainty calculations (0 &lt; float &lt; 1).</p> <code>cvrmse_threshold</code> <code>float</code> <p>Threshold for the CVRMSE to disqualify a model.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData","title":"<code>DailyBaselineData(df, is_electricity_data, settings=None)</code>","text":"<p>Data class to represent Daily Baseline Data.</p> <p>Only baseline data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of issues with the data, but none that will severely reduce the quality of the model built.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.settings","title":"<code>settings = self._settings_class()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyBaselineData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data, settings=None)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p> <p>Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe. The temperature column should have values in Fahrenheit.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame</code> <p>The meter data.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data.</p> required <code>is_electricity_data</code> <code>bool</code> <p>A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.</p> required <p>Returns:</p> Type Description <p>An instance of the Data class with the dataframe populated with the corrected data, along with warnings and disqualifications based on the input.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData","title":"<code>DailyReportingData(df, is_electricity_data, settings=None)</code>","text":"<p>Data class to represent Daily Reporting Data.</p> <p>Only reporting data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Meter data input is optional for the reporting class.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of issues with the data, but none that will severely reduce the quality of the model built.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.settings","title":"<code>settings = self._settings_class()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/daily_model/api/#opendsm.eemeter.models.daily.DailyReportingData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data=None, tzinfo=None, settings=None)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame | None</code> <p>The meter data to be used for the DailyReportingData instance.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data to be used for the DailyReportingData instance.</p> required <code>is_electricity_data</code> <code>bool | None</code> <p>Flag indicating whether the meter data represents electricity data.</p> <code>None</code> <code>tzinfo</code> <code>tzinfo | None</code> <p>Timezone information to be used for the meter data.</p> <code>None</code> <p>Returns:</p> Type Description <code>DailyReportingData</code> <p>An instance of the Data class.</p>"},{"location":"documentation/eemeter/daily_model/example/","title":"Example","text":"<p>In this example, we'll walk through creating a Daily Model and predicting usage with it.</p> <p>You can find a working example in the Example Code at the bottom of the page.</p> <p> 1) This example makes use of Matplotlib. Matplotlib is not a required dependency of OpenDSM. 2) If you run this example, it will download up to 150 MB of example data from the GitHub repo. </p>"},{"location":"documentation/eemeter/daily_model/example/#imports","title":"Imports","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport opendsm as odsm\nfrom opendsm import eemeter as em\n</code></pre>"},{"location":"documentation/eemeter/daily_model/example/#loading-data","title":"Loading data","text":"<p>The essential inputs to OpenDSM library functions are the following:</p> <ol> <li>Meter baseline data named <code>observed</code></li> <li>Meter reporting data <code>observed</code></li> <li>Temperature data from a nearby weather station for both named <code>temperature</code></li> <li>All data is expected to have a timezone-aware datetime index or column named <code>datetime</code></li> </ol> <p>Users of the library are responsible for obtaining and formatting this data (to get weather data, see EEweather, which helps perform site to weather station matching and can pull and cache temperature data directly from public (US) data sources).</p> <p>We utilize data classes to store meter data, perform transforms, and validate the data to ensure data compliance. The inputs into these data classes can either be pandas <code>DataFrame</code> if initializing the classes directly or <code>Series</code> if initializing the classes using <code>.from_series</code>.</p> <p>The test data contained within the OpenDSM library is derived from NREL ComStock simulations.</p> <p>If working with your own data instead of these samples, please refer directly to the excellent pandas documentation for instructions for loading data (e.g., pandas.read_csv).</p>"},{"location":"documentation/eemeter/daily_model/example/#important-notes-about-data","title":"Important notes about data","text":"<ul> <li>These models were developed and tested using Fahrenheit temperature. Please convert your temperatures accordingly</li> <li>It is expected that all data is trimmed to its appropriate time period (baseline and reporting) and does not contain extraneous datetimes</li> </ul> <p>Let us begin by loading some example data. Here we use a built-in utility function to load some example data.</p> <p>This function returns two dataframes of daily electricity data, one for the baseline period and one for the reporting period.</p> <pre><code>df_baseline, df_reporting =  odsm.test_data.load_test_data(\"daily_treatment_data\")\n</code></pre> <p>If we inspect these dataframes, we will notice that there are 100 meters for you to experiment with, indexed by meter id and datetime.</p> <pre><code>print(df_baseline)\n</code></pre> Returns <pre><code>id      datetime                    temperature observed\n108618  2018-01-01 00:00:00-06:00   -2.384038   16635.193673\n        2018-01-02 00:00:00-06:00   1.730000    15594.051162\n        2018-01-03 00:00:00-06:00   13.087946   11928.025899\n        2018-01-04 00:00:00-06:00   4.743269    14399.333812\n        2018-01-05 00:00:00-06:00   4.130577    14315.101721\n... ... ... ...\n120841  2018-12-27 00:00:00-06:00   52.010625   1153.749811\n        2018-12-28 00:00:00-06:00   35.270000   1704.076968\n        2018-12-29 00:00:00-06:00   29.630000   2151.225729\n        2018-12-30 00:00:00-06:00   34.250000   1331.123954\n        2018-12-31 00:00:00-06:00   43.311250   1723.397349\n</code></pre> <p>To simplify things, we will filter down to a single meter for the rest of the example. Let's filter down to the 15th id.</p> <pre><code>n = 15\n\nid = df_baseline.index.get_level_values(0).unique()[n]\n\ndf_baseline_n = df_baseline.loc[id]\ndf_reporting_n = df_reporting.loc[id]\n</code></pre> <p>If we inspect one of these dataframes, we will now notice that only a single meter is present with 365 days of data in each dataframe. </p> <pre><code>print(df_baseline_n)\n</code></pre> Returns <pre><code>                           temperature     observed\ndatetime                                           \n2018-01-01 00:00:00-06:00   -10.045000  9629.679232\n2018-01-02 00:00:00-06:00    -4.712500  8868.878051\n2018-01-03 00:00:00-06:00    11.352500  6109.322326\n2018-01-04 00:00:00-06:00     0.972500  7557.067633\n2018-01-05 00:00:00-06:00     3.147500  6650.189107\n...                                ...          ...\n2018-12-27 00:00:00-06:00    46.760000  2675.234259\n2018-12-28 00:00:00-06:00    35.323125  3561.451294\n2018-12-29 00:00:00-06:00    26.386250  3247.215055\n2018-12-30 00:00:00-06:00    28.463750  3048.525124\n2018-12-31 00:00:00-06:00    40.345250  3226.933132\n</code></pre> <p>Also notice the general structure of these dataframes for a single meter. We have three columns:</p> <ol> <li>A timezone-aware datetime index.</li> <li>A temperature column (float) in Fahrenheit (be sure to convert any other units to Fahrenheit first).</li> <li>Observed meter usage (float). The example here is electricity data in kWh, but it could also be gas data.</li> </ol> <p>We can stop to plot this data to get a better understanding of the general behavior of this meter. <pre><code>ax = df_baseline_n['observed'].plot(label='Observed Usage', color='blue')\ndf_baseline_n['temperature'].plot(ax=ax, secondary_y=True, label='Temperature (F)', color='orange')\n\nax.set_ylabel('Observed Usage (kWh)')\nax.right_ax.set_ylabel('Temperature (F)')\n\nax.legend(loc='upper left')\nax.right_ax.legend(loc='upper right')\n\nplt.title('Observed Usage and Temperature in the Baseline Period')\nplt.show()\n</code></pre></p> Returns <p> </p> <p>If we observe the data we can see a full year of data with observed usage peaking in the winter and lowering in the summer with warmer temperatures. It's clear that this site is located in a colder climate and uses more electricity in the winter.</p>"},{"location":"documentation/eemeter/daily_model/example/#loading-data-into-eemeter-data-objects","title":"Loading Data into EEmeter Data Objects","text":"<p>With our sample data loaded into dataframes, we can create our Baseline and Reporting Data objects. Note that only the baseline period is needed to fit a model, but we will use our reporting period data to predict against.</p> <pre><code>baseline_data = em.DailyBaselineData(df_baseline_n, is_electricity_data=True)\nreporting_data = em.DailyReportingData(df_reporting_n, is_electricity_data=True)\n</code></pre> <p>These classes are critical to ensure standardized data loaded into the model. These classes also scan the data to check for data sufficiency and other criteria that might cause a model to be disqualified (unable to build a model of sufficient integrity).</p> <p>As a note, you can also instantiate these data classes with two separate meter usage and temperature Series objects, both indexed by timezone-aware datetime.</p> Example <pre><code>baseline_data = em.DailyBaselineData.from_series(df_baseline_n['observed'], df_baseline_n['temperature'], is_electricity_data=True)\n</code></pre> <p>With data classes successfully instantiated, we can also check for any disqualifications or warnings before moving on to the model fitting step.</p> <pre><code>print(f\"Disqualifications: {baseline_data.disqualification}\")\nprint(f\"Warnings:          {baseline_data.warnings}\")\n</code></pre> Returns <pre><code>Disqualifications: []\nWarnings:          [EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.unable_to_confirm_daily_temperature_sufficiency), \n                    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.extreme_values_detected)]\n</code></pre> <p>From this, we can see that no disqualifications are present but there are some warnings to be aware of as we proceed. Neither of these warnings will necessarily stop us from creating a model.</p> <p>Before we move on, also notice that you can access the underlying dataframe in each object like follows to see exactly what will be loaded into the model.</p> <pre><code>print(baseline_data.df.head())\n</code></pre> Returns <pre><code>datetime                    season  weekday_weekend temperature observed\n2018-01-01 00:00:00-06:00   winter  weekday         -10.0450    9629.7\n2018-01-02 00:00:00-06:00   winter  weekday         -4.7125     8868.9\n2018-01-03 00:00:00-06:00   winter  weekday         11.3525     6109.3\n2018-01-04 00:00:00-06:00   winter  weekday         0.9725      7557.1\n2018-01-05 00:00:00-06:00   winter  weekday         3.1475      6650.2\n</code></pre>"},{"location":"documentation/eemeter/daily_model/example/#creating-the-model","title":"Creating the Model","text":"<p>The daily model follows the general process of: 1. Initialize 2. Fit 3. Predict</p> <p>We can do this easily as follows:</p> <pre><code>daily_model = em.DailyModel()\ndaily_model.fit(baseline_data)\n</code></pre> <p>Before we move to predicting against a dataframe, we can actually use the built in plot function (requiring matplotlib) to plot the performance of the model against the provided data.</p> <pre><code>daily_model.plot(baseline_data)\n</code></pre> Returns <p> </p> <p>From this graph we can also observe model splits and model types as described in the Model Splits section of the Methodology page. We can observe the following models:</p> <ol> <li>Summer/Shoulder/Winter - Weekday</li> <li>Summer/Shoulder/Winter - Weekend</li> </ol> <p>This illustrates that the weekends are different enough to warrant their own model compared to the weekdays. Each meter is treated separately and will be given its own unique splits if justified by the data. All of this complexity is handled under the hood, and the model will utilize the correct model when predicting usage automatically.</p> <p>We can also use this function to plot the model prediction against the reporting period as follows:</p> <pre><code>daily_model.plot(reporting_data)\n</code></pre> Returns <p> </p> <p>In this plot we can see that the site is using significantly less energy in colder temperatures compared to the model / baseline period. Perhaps this site installed an efficiency intervention that saves energy in colder temperatures?</p>"},{"location":"documentation/eemeter/daily_model/example/#predicting-with-the-model-and-calculating-savings","title":"Predicting with the Model and Calculating Savings","text":"<p>With our fit model, we can now predict across a given reporting period as follows:</p> <pre><code>df_results = daily_model.predict(reporting_data)\nprint(df_results.head())\n</code></pre> Returns <pre><code>datetime                    season  day_of_week weekday_weekend  temperature observed     predicted    predicted_unc  heating_load  cooling_load  model_split  model_type                                                  \n2019-01-01 00:00:00-06:00  winter            2         weekday     -10.0450  6821.633670  8458.769369     403.385708   6145.    508305           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-02 00:00:00-06:00  winter            3         weekday      -4.7125  5668.980225  7829.167990     403.385708   5515.    906926           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-03 00:00:00-06:00  winter            4         weekday      11.3525  3122.794390  5960.086410     403.385708   3646.    825346           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-04 00:00:00-06:00  winter            5         weekday       0.9725  3880.896300  7161.729548     403.385708   4848.    468484           0.0  wd-su_sh_wi  hdd_tidd_cdd_smooth\n2019-01-05 00:00:00-06:00  winter            6         weekend       3.1475  3182.209058  5213.370264     285.516312   3858.    054437           0.0  we-su_sh_wi  hdd_tidd_cdd_smooth\n</code></pre> <p>We can also plot the observed usage vs. the predicted usage.</p> <pre><code>ax = df_results['observed'].plot(label='Observed Usage', color='blue')\ndf_results['predicted'].plot(ax=ax, label='Predicted Usage', color='orange')\n\nax.set_ylabel('Observed Usage (kWh)')\nax.legend(loc='upper left')\nplt.title('Observed Usage and Temperature in the Baseline Period')\nplt.show()\n</code></pre> Returns <p> </p> <p>From here, we can easily calculate savings by subtracting observed usage from predicted usage.</p> <pre><code>df_results['savings'] = df_results['predicted'] - df_results['observed']\nprint(f\"Predicted Usage (kWh):  {round(df_results['predicted'].sum(), 2)}\")\nprint(f\"Observed Usage (kWh):   {round(df_results['observed'].sum(), 2)}\")\nprint(f\"Savings (kWh):          {round(df_results['savings'].sum(), 2)}\")\n</code></pre> Returns <pre><code>Predicted Usage (kWh):  1038465.06\nObserved Usage (kWh):   789252.05\nSavings (kWh):          249213.01\n</code></pre>"},{"location":"documentation/eemeter/daily_model/example/#model-serialization","title":"Model Serialization","text":"<p>After creating a model, we can also serialize it for storage and read it back in later.</p> <pre><code>saved_model = daily_model.to_json()\nprint(saved_model)\n</code></pre> Returns <pre><code>{\"submodels\": {\"wd-su_sh_wi\": {\"coefficients\": {\"model_type\": \"hdd_tidd_cdd_smooth\", \"intercept\": 2313.2610638676033, \"hdd_bp\": 41.27040090608855, \"hdd_beta\": 119.44918113103105, \"hdd_k\": 0.4726274184833831, \"cdd_bp\": 70.96439586012724, \"cdd_beta\": 64.46865583811494, \"cdd_k\": 0.17605359829111333}, \"temperature_constraints\": {\"T_min\": -10.045, \"T_max\": 83.00500000000001, \"T_min_seg\": 8.94425, \"T_max_seg\": 81.38}, \"f_unc\": 403.3857082521867}, \"we-su_sh_wi\": {\"coefficients\": {\"model_type\": \"hdd_tidd_cdd_smooth\", \"intercept\": 1355.3158273422803, \"hdd_bp\": 50.8894292209749, \"hdd_beta\": 80.73766873918538, \"hdd_k\": 0.4482831249857758, \"cdd_bp\": 74.53352300727671, \"cdd_beta\": 41.0269706642773, \"cdd_k\": 0.5237054341526147}, \"temperature_constraints\": {\"T_min\": -2.7850000000000015, \"T_max\": 82.34, \"T_min_seg\": 22.4675, \"T_max_seg\": 79.7525}, \"f_unc\": 285.5163122905078}}, \"info\": {\"metrics\": {\"num_model_params\": 14, \"wrmse\": 218.75309123080092, \"n\": 365, \"n_prime\": 125.66853004788871, \"ddof\": 351, \"ddof_autocorr\": 111.66853004788871, \"observed\": {\"sum\": 1038753.15993621, \"mean\": 2845.899068318384, \"variance\": 1143760.7395673955, \"std\": 1069.4675028103452, \"cvstd\": 0.37579249198120157, \"sum_squared\": 3373659320.017336, \"median\": 2697.2358494980817, \"MAD_scaled\": 602.7295755197579, \"iqr\": 953.5552891155535, \"skew\": 2.221492866364899, \"kurtosis\": 9.332585130726638}, \"predicted\": {\"sum\": 1038740.3421026455, \"mean\": 2845.863950966152, \"variance\": 1074489.9131218037, \"std\": 1036.5760527437453, \"cvstd\": 0.3642394965479058, \"sum_squared\": 3348302512.293626, \"median\": 2627.7907614770256, \"MAD_scaled\": 464.5595323515464, \"iqr\": 914.7262255954338, \"skew\": 1.616695269464077, \"kurtosis\": 4.280790657230931}, \"residuals\": {\"sum\": 12.81783356446158, \"mean\": 0.03511735223140159, \"variance\": 47852.91368980268, \"std\": 218.7530884120329, \"cvstd\": 6229.202218054072, \"sum_squared\": 17466313.946906358, \"median\": 11.83559927083752, \"MAD_scaled\": 113.71324840144126, \"iqr\": 154.18635619428915, \"skew\": 1.3547762272723773, \"kurtosis\": 15.583344758089789}, \"max_error\": 1593.5483136788926, \"mae\": 126.71422886475526, \"nmae\": 0.044525201288895165, \"pnmae\": 0.13288608464673915, \"medae\": 76.1375240548914, \"mbe\": 0.03511735223140159, \"nmbe\": 1.233963376366405e-05, \"pnmbe\": 3.682780918133632e-05, \"sse\": 17466313.946906358, \"mse\": 47852.914923031116, \"rmse\": 218.75309123080092, \"rmse_autocorr\": 372.8098372555297, \"rmse_adj\": 223.07303332387448, \"rmse_autocorr_adj\": 395.4897491902344, \"cvrmse\": 0.07686607500105763, \"cvrmse_autocorr\": 0.1309989666906282, \"cvrmse_adj\": 0.07838402837514766, \"cvrmse_autocorr_adj\": 0.1389682977843363, \"pnrmse\": 0.22940787359451376, \"pnrmse_autocorr\": 0.39096824432836, \"pnrmse_adj\": 0.23393822662425828, \"pnrmse_autocorr_adj\": 0.41475282419864834, \"r_squared\": 0.9582550959309059, \"r_squared_adj\": 0.9565852997681421, \"mape\": 0.04085618887177056, \"smape\": 0.04056430298847941, \"wape\": 0.04452520128889517, \"swape\": 0.04452547600292869, \"maape\": 0.04074758380763742, \"nse\": 0.9581617787115769, \"nnse\": 0.9598419212949566, \"kge\": 0.9627155493651588, \"a10\": 0.9178082191780822, \"a20\": 0.9972602739726028, \"a30\": 1.0, \"wi\": 0.9890978278885424, \"index_of_agreement\": 0.9106627590653706, \"pearson_r\": 0.9789050494970932, \"pi\": 0.968232858166701, \"pi_rating\": \"excellent\", \"explained_variance_score\": 0.9581617797897993}, \"baseline_timezone\": \"America/Chicago\", \"disqualification\": [], \"warnings\": [{\"qualified_name\": \"eemeter.sufficiency_criteria.extreme_values_detected\", \"description\": \"Extreme values (outside 3x IQR) must be flagged for manual review.\", \"data\": {\"n_extreme_values\": 8, \"median\": 2697.2358494980817, \"upper_quantile\": 3269.296428540127, \"lower_quantile\": 2315.7411394245737, \"lower_bound\": -544.9247279220867, \"upper_bound\": 6129.962295886788, \"min_value\": 1181.0132889040156, \"max_value\": 9629.679232340746}}]}, \"settings\": {\"developer_mode\": false, \"algorithm_choice\": \"nlopt_sbplx\", \"initial_guess_algorithm_choice\": \"nlopt_direct\", \"full_model\": \"hdd_tidd_cdd\", \"allow_smooth_model\": true, \"alpha_minimum\": -100, \"alpha_selection\": 2, \"alpha_final_type\": \"last\", \"alpha_final\": \"adaptive\", \"final_bounds_scalar\": 1, \"regularization_alpha\": 0.001, \"regularization_percent_lasso\": 1, \"segment_minimum_count\": 6, \"maximum_slope_oom_scalar\": 2, \"initial_step_percentage\": 0.1, \"split_selection\": {\"criteria\": \"bic\", \"penalty_multiplier\": 0.24, \"penalty_power\": 2.061, \"allow_separate_summer\": true, \"allow_separate_shoulder\": true, \"allow_separate_winter\": true, \"allow_separate_weekday_weekend\": true, \"reduce_splits_by_gaussian\": true, \"reduce_splits_num_std\": [1.4, 0.89]}, \"season\": {\"january\": \"winter\", \"february\": \"winter\", \"march\": \"shoulder\", \"april\": \"shoulder\", \"may\": \"shoulder\", \"june\": \"summer\", \"july\": \"summer\", \"august\": \"summer\", \"september\": \"summer\", \"october\": \"shoulder\", \"november\": \"winter\", \"december\": \"winter\", \"options\": [\"summer\", \"shoulder\", \"winter\"]}, \"weekday_weekend\": {\"monday\": \"weekday\", \"tuesday\": \"weekday\", \"wednesday\": \"weekday\", \"thursday\": \"weekday\", \"friday\": \"weekday\", \"saturday\": \"weekend\", \"sunday\": \"weekend\", \"options\": [\"weekday\", \"weekend\"]}, \"uncertainty_alpha\": 0.1, \"cvrmse_threshold\": 1, \"pnrmse_threshold\": 1.6}}\n</code></pre> <p>Afterwards, we can instantiate the model as follows:</p> <pre><code>loaded_model = em.DailyModel.from_json(saved_model)\n</code></pre>"},{"location":"documentation/eemeter/daily_model/example/#automatic-sufficiency-checking","title":"Automatic Sufficiency Checking","text":"<p>Two of the core features of the OpenDSM Data and Model classes are automatic data sufficiency and model sufficiency checking. This ensures that only acceptable data and models are allowed to be used for making measurements. Let's show an example of how this works by introducing too many NaN values into the observed data of the prior example.</p> <pre><code>daily_baseline_data_DQ = em.DailyBaselineData.from_series(\n    meter_data = df_baseline_n[\"observed\"], \n    temperature_data = df_baseline_n[\"temperature\"],\n    is_electricity_data=True\n    )\n\n# set rows 1:38 of observed to nan\ndf_baseline_n = daily_baseline_data_DQ.df\ndf_baseline_n.loc[df_baseline_n.index[1:37], \"observed\"] = np.nan\n\ndaily_baseline_data_DQ = em.DailyBaselineData(df_baseline_n, is_electricity_data=True)\nprint(f\"Disqualifications: {daily_baseline_data_DQ.disqualification}\")\n</code></pre> Returns <pre><code>Disqualifications: [\n    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.too_many_days_with_missing_observed_data), \n    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.too_many_days_with_missing_joint_data)\n]\n</code></pre> <p>If this data were to try to be fit on it would return an error by default.</p> <pre><code>try:\n    daily_model = em.DailyModel().fit(daily_baseline_data_DQ)\nexcept Exception as e:\n    print(f\"Exception: {e}\")\n</code></pre> Returns <pre><code>Exception: Can't fit model on disqualified baseline data\n</code></pre> <p>In some circumstances it may still be possible to fit a model on disqualified data for investigative purposes. This can be done by setting the <code>ignore_disqualification</code> flag to True.</p> <pre><code>daily_model = em.DailyModel().fit(daily_baseline_data_DQ, ignore_disqualification=True)\n</code></pre> <p>Please remember that enabling <code>ignore_disqualification</code> or making any changes to the model configuration fundamentally alters the model and such models are not approved for measurement purposes.</p>"},{"location":"documentation/eemeter/daily_model/example/#example-code","title":"Example Code","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport opendsm as odsm\nfrom opendsm import eemeter as em\n\ndf_baseline, df_reporting =  odsm.test_data.load_test_data(\"daily_treatment_data\")\n\nn = 15\n\nid = df_baseline.index.get_level_values(0).unique()[n]\n\ndf_baseline_n = df_baseline.loc[id]\ndf_reporting_n = df_reporting.loc[id]\n\nbaseline_data = em.DailyBaselineData(df_baseline_n, is_electricity_data=True)\nreporting_data = em.DailyReportingData(df_reporting_n, is_electricity_data=True)\n\nprint(f\"Disqualifications: {baseline_data.disqualification}\")\nprint(f\"Warnings:          {baseline_data.warnings}\")\n\ndaily_model = em.DailyModel()\ndaily_model.fit(baseline_data)\n\n# Save model to json\nsaved_model = daily_model.to_json()\nloaded_model = em.DailyModel.from_json(saved_model)\n\n# Model results\ndaily_model.plot(baseline_data)\ndaily_model.plot(reporting_data)\n\ndf_results = daily_model.predict(reporting_data)\ndf_results['savings'] = df_results['predicted'] - df_results['observed']\nprint(f\"Predicted Usage (kWh):  {round(df_results['predicted'].sum(), 2)}\")\nprint(f\"Observed Usage (kWh):   {round(df_results['observed'].sum(), 2)}\")\nprint(f\"Savings (kWh):          {round(df_results['savings'].sum(), 2)}\")\n</code></pre>"},{"location":"documentation/eemeter/daily_model/methodology/","title":"Methodology","text":"<p>The daily model is trained using daily energy usage intervals and predicts in daily intervals.</p>"},{"location":"documentation/eemeter/daily_model/methodology/#model-theory","title":"Model Theory","text":""},{"location":"documentation/eemeter/daily_model/methodology/#model-shape-and-balance-points","title":"Model Shape and Balance Points","text":"<p>The daily model, at its core, utilizes a piecewise linear regression model that predicts energy usage relative to temperature. The model determines temperature balance points at which energy usage starts changing relative to temperature.</p>"},{"location":"documentation/eemeter/daily_model/methodology/#nomenclature","title":"Nomenclature","text":"<ul> <li>Balance Points: Outdoor temperature thresholds beyond which heating and cooling effects are observed.</li> <li>Heating and Cooling Coefficients: Rate of increase of energy use per change in temperature beyond the balance points.</li> <li>Temperature Independent Load: The regression intercept (height of the flat line in the diagram).</li> </ul>"},{"location":"documentation/eemeter/daily_model/methodology/#model-archetypes","title":"Model Archetypes","text":"<p>Based on the site behavior, there are four different model types that may be generated:</p> <ul> <li>Heating and Cooling Loads</li> <li>Heating Only Load</li> <li>Cooling Only Load</li> <li>Temperature Independent Load</li> </ul>"},{"location":"documentation/eemeter/daily_model/methodology/#smooth-transitions","title":"Smooth Transitions","text":"<p>The daily model is designed to allow smooth transitions between model regimes. There are many reasons why a smooth transition might be favorable, but one example of this is inlet water temperature into a water heater. In this example, more energy will be required as the temperature decreases, which will be a smooth transition.</p>"},{"location":"documentation/eemeter/daily_model/methodology/#robust-adaptive-outlier-downweighting","title":"Robust, Adaptive Outlier Downweighting","text":"<p>While the majority of the time Sum of Squares Error (SSE) is the optimal metric to minimize to obtain the best model, there are instances where it is less effective at creating predictive models in data containing influential outliers. The daily model handles these outliers by downweighting them using a robust, adaptive loss function and procedure.</p>"},{"location":"documentation/eemeter/daily_model/methodology/#model-fit","title":"Model Fit","text":"<p>When the model is fit, each site will receive its own unique model fit and coefficients. The general model fitting process is as follows:</p> <ol> <li>Balance points are estimated with a global optimization algorithm.</li> <li>Sum of Squares Error (SSE) is minimized with Lasso inspired penalization.</li> <li>The best model type is determined (ex. cooling load only model) using the penalized SSE.</li> </ol> <p>The Lasso inspired penalization means that increased model complexity must be justified by decreased SSE and balanced against these general rules:</p> <ul> <li>Slopes are pushed to 0</li> <li>Intercept is pushed to 0</li> <li>Balance points are pushed together</li> <li>Balance points are pushed towards the nearest edge (most extreme temperature)</li> <li>Smoothing parameter is pushed to 0 (no smoothing)</li> </ul>"},{"location":"documentation/eemeter/daily_model/methodology/#model-splits","title":"Model Splits","text":"<p>The process described above is effective but may have shortcomings in real life data if energy usage changes fundamentally during different time periods.</p> <p>For example, what if a site is more populated during a particular season (for example, a Summer House or Ski Lodge) or during weekdays (for example, offices and most homes). This may result in models that fail to accurately predict energy usage because they are trying to account for all time periods at once.</p> <p>To combat this, the model will create \"splits\" that will store independent submodels for different seasons or weekday/weekend combinations, but only if necessary. </p> <p>The general process is as follows:</p> <ol> <li>Create submodels using all possible splits of season/weekday|weekend.</li> <li>Calculate modified BIC (Bayesian Information Criterion) for each preliminary combination.</li> <li>Select best combination with the smallest BICmod.</li> </ol> <p>This provides a standardized process for splitting the model to better predict energy usage by certain time periods (if the benefit outweighs the additional model complexity).</p>"},{"location":"documentation/eemeter/daily_model/methodology/#real-data-example","title":"Real Data Example","text":"<p>The daily model is a deceptively complex model capable of handling some complex situations. </p> <p>In this real example, we have three models:</p> <ol> <li>Summer/shoulder weekday model: a smoothed model with heating, temperature independent, and cooling regions.</li> <li>Winter weekday model: a model with heating and temperature independent regions that relies on adaptive downweighting (see the influential points at 0 kWh/day)</li> <li>Weekend model: an all-season model with significant usage decrease compared to the weekday models.</li> </ol> <p>*For additional information and validation details, see the References page.</p>"},{"location":"documentation/eemeter/daily_model/methodology/#sufficiency-criteria","title":"Sufficiency Criteria","text":"<p>To be completed</p>"},{"location":"documentation/eemeter/daily_model/references/","title":"References","text":"<p>If embedded pdf viewer fails to load, click here.</p>"},{"location":"documentation/eemeter/hourly_model/api/","title":"API","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel","title":"<code>HourlyModel(settings=None)</code>","text":"<p>A class to fit a model to the input meter data.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of settings.</p> <code>baseline_metrics</code> <code>dict</code> <p>A dictionary of metrics based on input baseline data and model fit.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict | BaseHourlySettings | None</code> <p>HourlySettings to use (generally left default). Will default to solar model if GHI is given to the fit step.</p> <code>None</code>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.settings","title":"<code>settings = _settings.BaseHourlySettings()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.is_fitted","title":"<code>is_fitted = False</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.baseline_metrics","title":"<code>baseline_metrics = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.baseline_hour_metrics","title":"<code>baseline_hour_metrics = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.warnings","title":"<code>warnings: list[EEMeterWarning] = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.disqualification","title":"<code>disqualification: list[EEMeterWarning] = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.baseline_timezone","title":"<code>baseline_timezone = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.error","title":"<code>error = dict()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.version","title":"<code>version = __version__</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.fit","title":"<code>fit(baseline_data, ignore_disqualification=False)</code>","text":"<p>Fit the model using baseline data.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_data</code> <code>HourlyBaselineData</code> <p>HourlyBaselineData object.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore disqualification errors / warnings.</p> <code>False</code> <p>Returns:</p> Type Description <code>HourlyModel</code> <p>The fitted model.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If baseline_data is not an HourlyBaselineData object.</p> <code>DataSufficiencyError</code> <p>If the model can't be fit on disqualified baseline data.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.predict","title":"<code>predict(reporting_data, ignore_disqualification=False)</code>","text":"<p>Predicts the energy consumption using the fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>reporting_data</code> <code>Union[HourlyBaselineData, HourlyReportingData]</code> <p>The data used for prediction.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore model disqualification. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with input data along with predicted energy consumption.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the model is not fitted.</p> <code>DisqualifiedModelError</code> <p>If the model is disqualified and ignore_disqualification is False.</p> <code>TypeError</code> <p>If the reporting data is not of type HourlyBaselineData or HourlyReportingData.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Model parameters.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.to_json","title":"<code>to_json()</code>","text":"<p>Returns a JSON string of model parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>Model parameters.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a instance of the class from a dictionary (such as one produced from the to_dict method).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the model data.</p> required <p>Returns:</p> Type Description <code>HourlyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <p>The JSON string representing the object.</p> required <p>Returns:</p> Type Description <code>HourlyModel</code> <p>An instance of the class.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyModel.plot","title":"<code>plot(df_eval)</code>","text":"<p>Plot a model fit with baseline or reporting data.</p> <p>Parameters:</p> Name Type Description Default <code>df_eval</code> <code>HourlyBaselineData | HourlyReportingData</code> <p>The baseline or reporting data object to plot.</p> required"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData","title":"<code>HourlyBaselineData(df, is_electricity_data, pv_start=None, settings=None, **kwargs)</code>","text":"<p>Data class to represent Hourly Baseline Data.</p> <p>Only baseline data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. Optionally, column 'ghi' can be included in order to fit on solar data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of issues with the data, but none that will severely reduce the quality of the model built.</p> <code>pv_start</code> <code>date</code> <p>Solar install date. If left unset, assumed to be at beginning of data.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.pv_start","title":"<code>pv_start = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.settings","title":"<code>settings = HourlyDataSettings()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.df","title":"<code>df</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyBaselineData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData","title":"<code>HourlyReportingData(df, is_electricity_data, pv_start=None, settings=None, **kwargs)</code>","text":"<p>Data class to represent Hourly Reporting Data.</p> <p>Only reporting data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Meter data input is optional for the reporting class.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. If GHI was provided during the baseline period, it should also be supplied for the reporting period with column name 'ghi'. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of issues with the data, but none that will severely reduce the quality of the model built.</p> <code>pv_start</code> <code>date</code> <p>Solar install date. If left unset, assumed to be at beginning of data.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.pv_start","title":"<code>pv_start = None</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.settings","title":"<code>settings = HourlyDataSettings()</code>  <code>instance-attribute</code>","text":""},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.df","title":"<code>df</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"documentation/eemeter/hourly_model/api/#opendsm.eemeter.models.hourly.HourlyReportingData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p>"},{"location":"documentation/eemeter/hourly_model/example/","title":"Example","text":"<p>A new tutorial is coming soon.</p>"},{"location":"documentation/eemeter/hourly_model/methodology/","title":"Methodology","text":"<p>This is a work in progress.</p>"},{"location":"documentation/eemeter/hourly_model/references/","title":"References","text":"<p>If embedded pdf viewer fails to load, click here.</p>"}]}